<!DOCTYPE html>
<html>
<head>
	<title>Reduction Test</title>
</head>
<body>
<script src="de405.js"></script>
<script src="sofa.src.js"></script>
<script src="ascp2020.405.js"></script>
<script>
"use strict";

simpleReduction2();

function simpleReduction2(){
	//convert Date to utc
	let utc1,utc2;

	let temp=IAU.dtf2d("UTC",2020,4,11,12,0,0);
	utc1=temp[1]; utc2=temp[2];
	reductionTest(utc1,utc2,4,297.26297, -21.16207, 176.5762,  30.5684); //Jupiter

/*
	iauDtf2d("UTC",2000,1,1,12,0,0,&utc1,&utc2);
	reductionTest(utc1,utc2, BODY_MOON,222.80147, -11.57774,146.3255,  33.6752);

	iauDtf2d("UTC",2020,4,11,16,0,0,&utc1,&utc2);
	reductionTest(utc1,utc2, BODY_MOON,249.19588, -20.90403, 261.7692, -24.3259);

	iauDtf2d("UTC",2020,4,11,12,0,0,&utc1,&utc2);
	reductionTest(utc1,utc2,BODY_JUPITER,297.26297, -21.16207, 176.5762,  30.5684);
*/
}

function reductionTest(utc1, utc2, bodyNum,
		expectedRA, expectedDec, expectedAz, expectedAlt){


	const de=new DE405();
	let temp;

	temp=IAU.utctai(utc1,utc2);
	console.log(temp);
	const atomic1=temp[1]; const atomic2=temp[2];

	//convert TAI to TT
	IAU.taitt(atomic1,atomic2);
	console.log(temp);
	const tt1=temp[1]; const tt2=temp[2];

	let jd=tt1+tt2;

	const earth=de.getEarth(jd);
	console.log(earth);

	let body=de.getAllPropertiesForSeries(bodyNum,jd);
	console.log(body);

	body[0]-=earth[0];
	body[1]-=earth[1];
	body[2]-=earth[2];
	body[3]-=earth[3];
	body[4]-=earth[4];
	body[5]-=earth[5];

	console.log(body);

	let distance = Math.sqrt(body[0] * body[0] + body[1] * body[1] + body[2] * body[2]);
	distance*=1000; //Convert from KM to meters
	const lightTime=distance/299792458.0;
	jd-=lightTime / 24.0 / 60.0 / 60.0;

	console.log(jd);

	body=de.getAllPropertiesForSeries(bodyNum,jd);
	console.log(body);

	body[0]-=earth[0];
	body[1]-=earth[1];
	body[2]-=earth[2];
	body[3]-=earth[3];
	body[4]-=earth[4];
	body[5]-=earth[5];
	console.log(body);

	let rnpb=IAU.pnm06a(0, jd);
	console.log(rnpb);

	body=IAU.rxp(rnpb,body);
	console.log(body);

	//Use UT1 for Earth Rotation Angle
	const era=IAU.era00(utc1,utc2);  //Probably needs to be GAST since we're using the equinox method
	console.log(era);

	//Get observer's xyz coordinates in J2000 coords
	const lat=38.2464000*Math.PI/180.0;
	const lon=274.236400*Math.PI/180.0;

	let observerPV=new Array();
	observerPV[0]=new Array();
	observerPV[1]=new Array();
	observerPV[0][0]=0;
	observerPV[0][1]=0;
	observerPV[0][2]=0;
	observerPV[1][0]=earth[3];
	observerPV[1][1]=earth[4];
	observerPV[1][2]=earth[5];
	observerPV=IAU.pvtob(lon,lat,0,0,0,0,era);
	console.log(observerPV);

	rnpb=IAU.tr(rnpb);
	console.log(rnpb);
	
	observerPV=IAU.rxpv(rnpb,observerPV);
	console.log(observerPV);

	//Convert body position to topocentric
	body[0]-=observerPV[0][0];
	body[1]-=observerPV[0][1];
	body[2]-=observerPV[0][2];	
}
</script>
void reductionTest(double utc1, double utc2, int bodyNum,
		double expectedRA, double expectedDec, double expectedAz, double expectedAlt){

	printf("Reductiontes2\r\n");
	//convert UTC to TAI
	double atomic1,atomic2;
	iauUtctai(utc1,utc2,&atomic1,&atomic2);

	//convert TAI to TT
	double tt1,tt2;
	iauTaitt(atomic1,atomic2,&tt1,&tt2);

	double et=(tt1-2451545.0+tt2)/365250.0;

	//Compute initial position
	double earth[3];
	double body[3];

	getBody(BODY_EARTH,et,earth);
	//vsop87a_full_getEarth(et,earth);

	getBody(bodyNum,et,body);
	body[0]-=earth[0];
	body[1]-=earth[1];
	body[2]-=earth[2];

	//Compute light time to body, then recompute for apparent position
	double distance = sqrt(body[0] * body[0] + body[1] * body[1] + body[2] * body[2]);
	distance*=1.496e+11; //Convert from AU to meters
	double lightTime=distance/299792458.0;
	et-=lightTime / 24.0 / 60.0 / 60.0 / 365250.0;

	getBody(bodyNum,et,body);
	body[0]-=earth[0];
	body[1]-=earth[1];
	body[2]-=earth[2];

	double earthVelocity[3];
	vsop87a_full_velocities_getEarth(et,earthVelocity);

	//Convert VSOP87 coordinates to J2000
	rotvsop2J2000(body);
	rotvsop2J2000(earthVelocity);  //Need to add in Earth rotation component of observer velocity

	//Get the precession, nutation, and bias matrix
	double rnpb[3][3];
	iauPnm06a(tt1, tt2, rnpb);

	iauRxp(rnpb,body,body);

	//Use UT1 for Earth Rotation Angle
	double era=iauEra00(utc1,utc2);  //Probably needs to be GAST since we're using the equinox method

	//Get observer's xyz coordinates in J2000 coords
	double lat=38.2464000*PI/180.0;
	double lon=274.236400*PI/180.0;
	double observerPV[2][3];
	observerPV[1][0]=earthVelocity[0];
	observerPV[1][1]=earthVelocity[1];
	observerPV[1][2]=earthVelocity[2];
	iauPvtob(lon,lat,0,0,0,0,era,observerPV);

	iauTr(rnpb,rnpb);
	iauRxpv(rnpb,observerPV,observerPV);

	observerPV[0][0]/=1.49597870691E+11; //Convert meters to AU
	observerPV[0][1]/=1.49597870691E+11;
	observerPV[0][2]/=1.49597870691E+11;
	//observerPV[1][0]*=86400.0/1.49597870691E+11; //Convert meters/second to AU/day
	//observerPV[1][1]*=86400.0/1.49597870691E+11;
	//observerPV[1][2]*=86400.0/1.49597870691E+11;

	/*
	printf("Observer Position and Velocity:\r\n%2.10f %2.10f %2.10f\r\n%2.10f %2.10f %2.10f\r\n\r\n",
			observerPV[0][0],observerPV[0][1],observerPV[0][2],
			observerPV[1][0],observerPV[1][1],observerPV[1][2]
			);
	*/

	//Convert body position to topocentric
	body[0]-=observerPV[0][0];
	body[1]-=observerPV[0][1];
	body[2]-=observerPV[0][2];

	//Light abberation
	//TODO: Convert earthVelocity to units of c (convert AU/d to m/s)
	double CR =  (149597870.7e3/299792458.0)/86400.0;
	earthVelocity[0]*=CR;
	earthVelocity[1]*=CR;
	earthVelocity[2]*=CR;

	double lengthV=sqrt(earthVelocity[0]*earthVelocity[0]+earthVelocity[1]*earthVelocity[1]+earthVelocity[2]*earthVelocity[2]);
	double sunDistance=sqrt(earth[0]*earth[0]+earth[1]*earth[1]+earth[2]*earth[2]);
	double bodyLen=sqrt(body[0]*body[0]+body[1]*body[1]+body[2]*body[2]);
	double bodyUnitVector[3];
	bodyUnitVector[0]=body[0]/bodyLen;
	bodyUnitVector[1]=body[1]/bodyLen;
	bodyUnitVector[2]=body[2]/bodyLen;
	double lorenzFactor=sqrt(1-(lengthV*lengthV));
	double bodyDirection[3];
	iauAb(bodyUnitVector,earthVelocity,sunDistance,lorenzFactor,bodyDirection);

	body[0]=bodyDirection[0];
	body[1]=bodyDirection[1];
	body[2]=bodyDirection[2];



	//TODO:  add the geocentric observer velocity to the heliocentric velocity

	//Convert coords to polar, which gives RA/DEC
	double r = sqrt(body[0] * body[0] + body[1] * body[1] + body[2] * body[2]);
	double dec = acos(body[2] / r);
	double ra = atan2(body[1], body[0]);

	if(ra<0) ra+=2*PI;
	if(dec<0) dec+=2*PI;
	dec=.5*PI-dec;

	printf("Body: %f %f\r\n",ra*180.0/PI,dec*180.0/PI);
	printf("Diff: %15.10f %15.10f\r\n",ra*180.0/PI-expectedRA,dec*180.0/PI-(expectedDec));

	//Convert to altaz
	double GAST=iauGst06a(utc1,utc2,tt1,tt2);

	double h=GAST + lon - ra;

	double sina=sin(dec)*sin(lat)+cos(dec)*cos(h)*cos(lat);
	double a=asin(sina);

	double cosAz=(sin(dec)*cos(lat)-cos(dec)*cos(h)*sin(lat))/cos(a);
	double Az=acos(cosAz);

	if(sin(h)>0){Az=2.0*PI-Az;}

	double alt=a;
	double az=Az;

	printf("Alt Az: %f %f\r\n",alt*180.0/PI,az*180.0/PI);
	printf("Diff  : %15.10f %15.10f\r\n",alt*180.0/PI-expectedAlt,az*180.0/PI-expectedAz);


}

</body>
</html>