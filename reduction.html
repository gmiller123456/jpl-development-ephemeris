<!DOCTYPE html>
<html>
<head>
	<title>Reduction Test</title>
</head>
<body>
<script src="de405.js"></script>
<script src="sofa.src.js"></script>
<script src="ascp2020.405.js"></script>
<script>
"use strict";

simpleReduction2();

function simpleReduction2(){
	//convert Date to utc
	let utc1,utc2;

/*
*****************************************************************************************************************************************************************************************************
 Date__(UT)__HR:MN:SC.fff Date_________JDUT     R.A._(ICRF/J2000)__DEC. R.A._(airls-appar)_DEC. Azi_(a-appr)_Elev L_Ap_Sid_Time  APmag  S-brt            delta      deldot       TDB-UT L_Ap_Hour_Ang
*****************************************************************************************************************************************************************************************************
$$SOE
 2020-Apr-11 12:00:00.000 2458951.000000000 *m  297.2629676 -21.1620697 297.5557860 -21.1110947 176.5760  30.5683 19.6263848186  -2.21   5.43 5.15430074078189 -27.7391363    69.185662  -0.210667585
$$EOE
*****************************************************************************************************************************************************************************************************

Instant
X = 1.895001240666616E+08 Y =-6.892597258456213E+08 Z =-3.000531476496547E+08
 VX= 1.080788128926494E+06 VY= 3.125871377265289E+05 VZ= 1.076785300280079E+05

Light time
 X = 1.894677755680633E+08 Y =-6.892690809401206E+08 Z =-3.000563701769956E+08
 VX= 1.080798941769749E+06 VY= 3.125377818587692E+05 VZ= 1.076567749453240E+05

Earth
 X =-1.399289753760920E+08 Y =-5.005544968068058E+07 Z =-2.169113344200468E+07
 VX= 9.107248358811822E+05 VY=-2.201772179145565E+06 VZ=-9.543336271408523E+05
*/

	let temp=IAU.dtf2d("UTC",2020,4,11,12,0,0);
	console.log("JD=",temp[1]+temp[2])
	utc1=temp[1]; utc2=temp[2];
	reductionTest(utc1,utc2,4,297.26297, -21.16207, 176.5762,  30.5684); //Jupiter

/*
	iauDtf2d("UTC",2000,1,1,12,0,0,&utc1,&utc2);
	reductionTest(utc1,utc2, BODY_MOON,222.80147, -11.57774,146.3255,  33.6752);

	iauDtf2d("UTC",2020,4,11,16,0,0,&utc1,&utc2);
	reductionTest(utc1,utc2, BODY_MOON,249.19588, -20.90403, 261.7692, -24.3259);

	iauDtf2d("UTC",2020,4,11,12,0,0,&utc1,&utc2);
	reductionTest(utc1,utc2,BODY_JUPITER,297.26297, -21.16207, 176.5762,  30.5684);
*/
}

function reductionTest(utc1, utc2, bodyNum,
		expectedRAJ2000, expectedDecJ2000, expectedAz, expectedAlt){


	const de=new DE405();
	let temp;

	temp=IAU.utctai(utc1,utc2);
	console.log(temp);
	const atomic1=temp[1]; const atomic2=temp[2];

	//convert TAI to TT
	IAU.taitt(atomic1,atomic2);
	console.log(temp);
	const tt1=temp[1]; const tt2=temp[2];

	let jd=tt1+tt2;

	const earth=de.getEarth(utc1+utc2-69.185662/60.0/60.0/24.0);
	//const earth=de.getEarth(jd);
	console.log(earth);

	let body=de.getAllPropertiesForSeries(bodyNum,jd);
	console.log(body);

	body[0]-=earth[0];
	body[1]-=earth[1];
	body[2]-=earth[2];
	body[3]-=earth[3];
	body[4]-=earth[4];
	body[5]-=earth[5];

	console.log(body);

	let distance = Math.sqrt(body[0] * body[0] + body[1] * body[1] + body[2] * body[2]);
	distance*=1000; //Convert from KM to meters
	const lightTime=distance/299792458.0;
	jd-=lightTime / 24.0 / 60.0 / 60.0;

	console.log(jd);

	body=de.getAllPropertiesForSeries(bodyNum,jd);
	console.log(body);

	body[0]-=earth[0];
	body[1]-=earth[1];
	body[2]-=earth[2];
	body[3]-=earth[3];
	body[4]-=earth[4];
	body[5]-=earth[5];
	console.log(body);

	let rnpb=IAU.pnm06a(0, jd);
	console.log(rnpb);

	//body=IAU.rxp(rnpb,body);
	console.log(body);

	//Use UT1 for Earth Rotation Angle
	const era=IAU.era00(utc1,utc2);  //Probably needs to be GAST since we're using the equinox method
	console.log(era);

	//Get observer's xyz coordinates in J2000 coords
	const lat=38.2464000*Math.PI/180.0;
	const lon=274.236400*Math.PI/180.0;

	let observerPV=new Array();
	observerPV[0]=new Array();
	observerPV[1]=new Array();
	observerPV[0][0]=0;
	observerPV[0][1]=0;
	observerPV[0][2]=0;
	observerPV[1][0]=earth[3];
	observerPV[1][1]=earth[4];
	observerPV[1][2]=earth[5];
	observerPV=IAU.pvtob(lon,lat,0,0,0,0,era);
	console.log(observerPV);

	rnpb=IAU.tr(rnpb);
	console.log(rnpb);
	
	//observerPV=IAU.rxpv(rnpb,observerPV);
	console.log(observerPV);

	//Convert body position to topocentric
	body[0]-=observerPV[0][0];
	body[1]-=observerPV[0][1];
	body[2]-=observerPV[0][2];	

	console.log(`body topocentric ${body[0]/1.49597870691E+8} ${body[1]/1.49597870691E+8} ${body[2]/1.49597870691E+8} `);
	const km2AU=1.0/1.49597870691E+11;
	const CR=(1/299792458.0)/86400.0;
	//const CR=(149597870.7e3/299792458.0)/86400.0*km2AU;
	console.log(`earth vel1 ${earth[0]*km2AU} ${earth[1]*km2AU} ${earth[2]*km2AU} `);
	console.log(`earth vel2 ${earth[0]*CR} ${earth[1]*CR} ${earth[2]*CR} `);

	//Convert coords to polar, which gives RA/DEC
	const r = Math.sqrt(body[0] * body[0] + body[1] * body[1] + body[2] * body[2]);
	let dec = Math.acos(body[2] / r);
	let ra = Math.atan2(body[1], body[0]);

	if(ra<0) ra+=2*Math.PI;
	if(dec<0) dec+=2*Math.PI;
	dec=.5*Math.PI-dec;

	console.log(`Body J2000: ${ra*180.0/Math.PI} , ${dec*180.0/Math.PI}`);
	console.log(`Diff ${ra*180.0/Math.PI-expectedRAJ2000}, ${dec*180.0/Math.PI-(expectedDecJ2000)}`);

	//Convert to altaz
	const GAST=IAU.gst06a(utc1,utc2,tt1,tt2);
	console.log("GAST="+GAST);

	const h=GAST + lon - ra;
	console.log("LST="+(GAST + lon)*180.0/Math.PI);
	console.log("h="+h);

	const sina=Math.sin(dec)*Math.sin(lat)+Math.cos(dec)*Math.cos(h)*Math.cos(lat);
	const a=Math.asin(sina);

	const cosAz=(Math.sin(dec)*Math.cos(lat)-Math.cos(dec)*Math.cos(h)*Math.sin(lat))/Math.cos(a);
	const Az=Math.acos(cosAz);

	if(Math.sin(h)>0){Az=2.0*Math.PI-Az;}

	const alt=a;
	const az=Az;

	console.log(`Alt Az: ${alt*180.0/Math.PI}, ${az*180.0/Math.PI}`);
	console.log(`Diff  : ${alt*180.0/Math.PI-expectedAlt}, ${az*180.0/Math.PI-expectedAz}`);


}
</script>
void reductionTest(double utc1, double utc2, int bodyNum,
		double expectedRA, double expectedDec, double expectedAz, double expectedAlt){

	printf("Reductiontes2\r\n");
	//convert UTC to TAI
	double atomic1,atomic2;
	iauUtctai(utc1,utc2,&atomic1,&atomic2);

	//convert TAI to TT
	double tt1,tt2;
	iauTaitt(atomic1,atomic2,&tt1,&tt2);

	double et=(tt1-2451545.0+tt2)/365250.0;

	//Compute initial position
	double earth[3];
	double body[3];

	getBody(BODY_EARTH,et,earth);
	//vsop87a_full_getEarth(et,earth);

	getBody(bodyNum,et,body);
	body[0]-=earth[0];
	body[1]-=earth[1];
	body[2]-=earth[2];

	//Compute light time to body, then recompute for apparent position
	double distance = sqrt(body[0] * body[0] + body[1] * body[1] + body[2] * body[2]);
	distance*=1.496e+11; //Convert from AU to meters
	double lightTime=distance/299792458.0;
	et-=lightTime / 24.0 / 60.0 / 60.0 / 365250.0;

	getBody(bodyNum,et,body);
	body[0]-=earth[0];
	body[1]-=earth[1];
	body[2]-=earth[2];

	double earthVelocity[3];
	vsop87a_full_velocities_getEarth(et,earthVelocity);

	//Convert VSOP87 coordinates to J2000
	rotvsop2J2000(body);
	rotvsop2J2000(earthVelocity);  //Need to add in Earth rotation component of observer velocity

	//Get the precession, nutation, and bias matrix
	double rnpb[3][3];
	iauPnm06a(tt1, tt2, rnpb);

	iauRxp(rnpb,body,body);

	//Use UT1 for Earth Rotation Angle
	double era=iauEra00(utc1,utc2);  //Probably needs to be GAST since we're using the equinox method

	//Get observer's xyz coordinates in J2000 coords
	double lat=38.2464000*PI/180.0;
	double lon=274.236400*PI/180.0;
	double observerPV[2][3];
	observerPV[1][0]=earthVelocity[0];
	observerPV[1][1]=earthVelocity[1];
	observerPV[1][2]=earthVelocity[2];
	iauPvtob(lon,lat,0,0,0,0,era,observerPV);

	iauTr(rnpb,rnpb);
	iauRxpv(rnpb,observerPV,observerPV);

	observerPV[0][0]/=1.49597870691E+11; //Convert meters to AU
	observerPV[0][1]/=1.49597870691E+11;
	observerPV[0][2]/=1.49597870691E+11;
	//observerPV[1][0]*=86400.0/1.49597870691E+11; //Convert meters/second to AU/day
	//observerPV[1][1]*=86400.0/1.49597870691E+11;
	//observerPV[1][2]*=86400.0/1.49597870691E+11;

	/*
	printf("Observer Position and Velocity:\r\n%2.10f %2.10f %2.10f\r\n%2.10f %2.10f %2.10f\r\n\r\n",
			observerPV[0][0],observerPV[0][1],observerPV[0][2],
			observerPV[1][0],observerPV[1][1],observerPV[1][2]
			);
	*/

	//Convert body position to topocentric
	body[0]-=observerPV[0][0];
	body[1]-=observerPV[0][1];
	body[2]-=observerPV[0][2];

	//Light abberation
	//TODO: Convert earthVelocity to units of c (convert AU/d to m/s)
	double CR =  (149597870.7e3/299792458.0)/86400.0;
	earthVelocity[0]*=CR;
	earthVelocity[1]*=CR;
	earthVelocity[2]*=CR;

	double lengthV=sqrt(earthVelocity[0]*earthVelocity[0]+earthVelocity[1]*earthVelocity[1]+earthVelocity[2]*earthVelocity[2]);
	double sunDistance=sqrt(earth[0]*earth[0]+earth[1]*earth[1]+earth[2]*earth[2]);
	double bodyLen=sqrt(body[0]*body[0]+body[1]*body[1]+body[2]*body[2]);
	double bodyUnitVector[3];
	bodyUnitVector[0]=body[0]/bodyLen;
	bodyUnitVector[1]=body[1]/bodyLen;
	bodyUnitVector[2]=body[2]/bodyLen;
	double lorenzFactor=sqrt(1-(lengthV*lengthV));
	double bodyDirection[3];
	iauAb(bodyUnitVector,earthVelocity,sunDistance,lorenzFactor,bodyDirection);

	body[0]=bodyDirection[0];
	body[1]=bodyDirection[1];
	body[2]=bodyDirection[2];



	//TODO:  add the geocentric observer velocity to the heliocentric velocity

	//Convert coords to polar, which gives RA/DEC
	double r = sqrt(body[0] * body[0] + body[1] * body[1] + body[2] * body[2]);
	double dec = acos(body[2] / r);
	double ra = atan2(body[1], body[0]);

	if(ra<0) ra+=2*PI;
	if(dec<0) dec+=2*PI;
	dec=.5*PI-dec;

	printf("Body: %f %f\r\n",ra*180.0/PI,dec*180.0/PI);
	printf("Diff: %15.10f %15.10f\r\n",ra*180.0/PI-expectedRA,dec*180.0/PI-(expectedDec));

	//Convert to altaz
	double GAST=iauGst06a(utc1,utc2,tt1,tt2);

	double h=GAST + lon - ra;

	double sina=sin(dec)*sin(lat)+cos(dec)*cos(h)*cos(lat);
	double a=asin(sina);

	double cosAz=(sin(dec)*cos(lat)-cos(dec)*cos(h)*sin(lat))/cos(a);
	double Az=acos(cosAz);

	if(sin(h)>0){Az=2.0*PI-Az;}

	double alt=a;
	double az=Az;

	printf("Alt Az: %f %f\r\n",alt*180.0/PI,az*180.0/PI);
	printf("Diff  : %15.10f %15.10f\r\n",alt*180.0/PI-expectedAlt,az*180.0/PI-expectedAz);


}

</body>
</html>